package libwraith

import (
	"context"
	"errors"
	"sync"
	"time"
)

type Wraith struct {
	// Keep track of the time Wraith was initialised/started so it
	// can be retrieved by modules if needed.
	initTime time.Time

	// A fingerprint to uniquely identify this Wraith. It is
	// generated on init. This helps to target individual Wraiths
	// with commands, for instance.
	fprint string

	// A bool keeping track of whether this instance of Wraith is
	// running. This prevents multiple instances from being started
	// and simoultaneously attempting to edit things.
	running bool

	runningMutex sync.Mutex

	// An instance of the SharedMemory object used to facilitate
	// communication between modules and Wraith.
	shm shm

	// A map keeping track of which modules are registered to
	// prevent modules from being registered twice.
	mods map[string]struct{}

	// A mutex to protect access to Wraith.mods
	modsMutex sync.RWMutex

	// An instance of WraithConf storing all configuration necessary
	// for Wraith to work correctly.
	conf Config

	// A copy of the context which controls Wraith's aliveness
	ctx context.Context

	// A copy of the function which kills Wraith's context
	ctxCancel context.CancelFunc
}

// Helper method to be deferred at the start of all Wraith methods
// to ensure none of them panic and cause the entire program to crash.
// Wraith is meant to be silent when embedded in other software, and
// reliable.
func (w *Wraith) catch() {
	recover()
}

// Spawn an instance of Wraith running synchronously. If you would
// like Wraith to run asynchronously, start this function in a
// goroutine. It can then be stopped with Wraith.Kill().
//
// The first argument is an instance of WraithConf containing the
// configuration for this instance of Wraith. It should be fully
// initialised and filled out. An uninitialised config can lead to
// undefined behaviour.
//
// The following arguments are modules which should be available to
// Wraith. In case of a name conflict, the first module in the
// list with the name will be chosen, the others will be discarded.
//
// Modules are initialised and started in the order they are given.
// It is highly recommended to pass the comms manager module first
// (possibly preceded by modules it depends on) to make sure module
// communications are not lost.
func (w *Wraith) Spawn(conf Config, mods ...mod) {
	defer w.catch()

	// Make sure only one instance runs
	// If another instance is in any state but inactive, exit immediately
	w.runningMutex.Lock()
	if w.running {
		w.runningMutex.Unlock()
		return
	}
	w.running = true
	w.runningMutex.Unlock()

	// Prepare on-exit cleanup
	defer func() {
		// Mark Wraith as dead
		w.runningMutex.Lock()
		w.running = false
		w.runningMutex.Unlock()
	}()

	// Take note of start time
	w.initTime = time.Now()

	// Save a copy of the config
	w.conf = conf

	// Create a context to control the Wraith's lifetime
	w.ctx, w.ctxCancel = context.WithCancel(context.Background())

	// Init map of modules
	w.mods = make(map[string]struct{})

	// Save a copy of the passed modules in the `modules` field, using the
	// module name as the key. Also start the modules while we're at it.
	w.ModsReg(mods...)

	// Run mainloop
	// This is the place where any functions which need to be
	// carried out by Wraith itself are handled, based on an event
	// loop. Most functions are carried out by modules, so there
	// shouldn't be too much here.
	for {
		select {
		case <-w.ctx.Done():
			return
		}
	}
}

// If the Wraith is running, this method will kill it and its modules by
// cancelling the Wraith's context. Otherwise it's a no-op.
func (w *Wraith) Kill() {
	// If Wraith is not active, do nothing
	if w.ctx == nil || w.ctx.Err() != nil || w.ctxCancel == nil {
		return
	}

	w.ctxCancel()
}

//
// Proxy Methods
//

// These are methods which allow access to Wraith's internal
// properties in a limitted manner, to make sure all access
// is safe and will not cause unexpected behaviour.

// InitTime

// Return the time at which Wraith begun initialisation (recorded
// as soon as Wraith confirms that it is the only running instance).
// This will be the time.Time zero value if Wraith has not yet
// started initialisation.
func (w *Wraith) GetInitTime() time.Time {
	defer w.catch()

	return w.initTime
}

// Fingerprint

// Return Wraith's fingerprint as generated by the configured
// generator. This method checks if the fingerprint has been
// cached and returns the cached value if so. Otherwise, it
// will run the generator function.
func (w *Wraith) GetFingerprint() string {
	defer w.catch()

	if w.fprint == "" {
		w.fprint = w.conf.FingerprintGenerator()
	}
	return w.fprint
}

// SharedMemory

// Proxy to SharedMemory.Get()
// Disallows reading from protected cells.
func (w *Wraith) SHMGet(cellname string) any {
	defer w.catch()

	return w.shm.Get(cellname)
}

// Proxy to SharedMemory.Set()
// Disallows writing to protected cells.
func (w *Wraith) SHMSet(cellname string, value any) {
	defer w.catch()

	w.shm.Set(cellname, value)
}

// Proxy to SharedMemory.Watch()
func (w *Wraith) SHMWatch(cellname string) (chan any, int) {
	defer w.catch()

	return w.shm.Watch(cellname)
}

// Proxy to SharedMemory.Unwatch()
func (w *Wraith) SHMUnwatch(cellname string, watchId int) {
	defer w.catch()

	w.shm.Unwatch(cellname, watchId)
}

// Modules

// Add a module to the list of available modules
// The modules are started automatically
// Panics if Wraith is not running by the time this method is called
func (w *Wraith) ModsReg(mods ...mod) {
	if !w.running || w.ctx == nil || w.ctx.Err() != nil {
		panic("not running")
	}

	defer w.catch()

	w.modsMutex.Lock()
	defer w.modsMutex.Unlock()

	for _, mod := range mods {
		modname := mod.WraithModuleName()

		// Ignore module if already exists
		if _, exists := w.mods[modname]; !exists {
			w.mods[modname] = struct{}{}

			// Run the module in a goroutine
			go func() {
				// Keep track of when and how many times the module has crashed
				// as not to re-start crashlooped modules.
				var moduleCrashCount int
				var lastModuleCrashTime time.Time

				for {
					// Create a context derived from Wraith's context to control the
					// module's lifetime
					moduleCtx, moduleCtxCancel := context.WithCancel(w.ctx)
					defer moduleCtxCancel()

					// Run the module and catch any panics or errors
					err := func() (err error) {
						defer func() {
							if r := recover(); r != nil {
								rstr, ok := r.(string)
								if ok {
									err = errors.New(rstr)
								} else {
									err = errors.New("panic")
								}
							}
						}()
						return mod.Mainloop(moduleCtx, w)
					}()

					// If there were some errors, report them
					if err != nil {
						w.SHMSet(SHM_ERRS, err)
					}

					// If Wraith has exited, do not restart the module
					if !w.running || w.ctx == nil || w.ctx.Err() != nil {
						return
					}

					// Clear crash count if the last crash was a long time ago
					if time.Since(lastModuleCrashTime) > w.conf.ModuleCrashloopDetectTime {
						moduleCrashCount = 0
					}

					// We have gotten here so the module has crashed and it wasn't
					// supposed to. Note that down.
					moduleCrashCount += 1
					lastModuleCrashTime = time.Now()

					// If the crash count has exceeded the max, do not restart
					if moduleCrashCount > w.conf.ModuleCrashloopDetectCount {
						return
					}

					moduleCtxCancel()
				}
			}()
		}
	}
}

// Get a list of available modules
func (w *Wraith) ModsGet() []string {
	defer w.catch()

	w.modsMutex.Lock()
	defer w.modsMutex.Unlock()

	mods := make([]string, len(w.mods))
	index := 0
	for modname := range w.mods {
		mods[index] = modname
		index++
	}
	return mods
}
